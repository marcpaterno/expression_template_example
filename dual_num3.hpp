#ifndef DUAL_NUM_HPP
#define DUAL_NUM_HPP

namespace duals {

  // Demonstration of the use of expression template to support dual numbers.

  // Forward declaration of class templates defined in this header.
  class DualNum;
  template <typename LHS, typename RHS>
  class DualNumSum;
  template <typename LHS, typename RHS>
  class DualNumProduct;

  // We use free functions for our generic interface because the primitive type
  // double does not have member functions real() and dual().

  // We define an overload set for the functions double() and real().
  inline double
  dual(double)
  {
    return 0.0;
  }
  inline double
  real(double x)
  {
    return x;
  }

  // Implementations of the following overloads come after the class and class
  // templates are defined.
  double dual(DualNum const& v);
  double real(DualNum const& v);


  // template <typename LHS, typename RHS>
  // DualNumSum<LHS, RHS>::value_type dual(DualNumSum<LHS, RHS) const& v) {
  //   return v.dual();
  // }
  // template <typename LHS, typename RHS>
  // DualNumSum<LHS, RHS>::value_type real(DualNumSum<LHS, RHS) const& v) {
  //   return v.real();
  // }

  // template <typename LHS, typename RHS>
  // DualNumProduct<LHS, RHS>::value_type dual(DualNumProduct<LHS, RHS> const&
  // v) {
  //   return v.real();
  // }

  // expression template version of addition for DualNum uses the type
  // DualNumSum to represent the unevaluated addition.
  template <typename LHS, typename RHS>
  class DualNumSum {
  public:
    using value_type = typename LHS::value_type;

    DualNumSum(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

    value_type
    real() const
    {
      return real(lhs) + real(lhs);
    }
    value_type
    dual() const
    {
      return dual(lhs) + dual(rhs);
    }

  private:
    // We contain references to avoid copying. This is acceptable because the
    // lifetime of an expression object is always, by construction, long enough
    // to let it be evaluated.
    LHS const& lhs;
    RHS const& rhs;
  };

  template <typename LHS, typename RHS>
  typename DualNumSum<LHS, RHS>::value_type
  dual(DualNumSum<LHS, RHS> const& v)
  {
    return v.dual();
  }

  template <typename LHS, typename RHS>
  typename DualNumSum<LHS, RHS>::value_type
  real(DualNumSum<LHS, RHS> const& v)
  {
    return v.real();
  }

  // expression template version of multiplication for DualNum uses the type
  // DualNumProduct to represent the unevaluated multiplication.

  template <typename LHS, typename RHS>
  class DualNumProduct {
  public:
    using value_type = typename LHS::value_type;

    DualNumProduct(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

    value_type
    real() const
    {
      return real(lhs) * real(rhs);
    }
    value_type
    dual() const
    {
      return real(lhs) * dual(rhs) + dual(lhs) * real(rhs);
    }

  private:
    // We contain references to avoid copying. This is acceptable because the
    // lifetime of an expression object is always, by construction, long enough
    // to let it be evaluated.
    LHS const& lhs;
    RHS const& rhs;
  };

  template <typename LHS, typename RHS>
  typename DualNumProduct<LHS, RHS>::value_type
  dual(DualNumProduct<LHS, RHS> const& v)
  {
    return v.dual();
  }

  template <typename LHS, typename RHS>
  typename DualNumProduct<LHS, RHS>::value_type
  real(DualNumProduct<LHS, RHS> const& v)
  {
    return v.real();
  }

  class DualNum {
  public:
    // We need a nested type value_type, so that DualNum can be used
    // withh the DualNumSum template.
    using value_type = double;

    // Serves as default constructor, as well as 1- and 2-arg constructors.
    DualNum(double real = 0.0, double dual = 0.0) : _real(real), _dual(dual) {}

    // This constructor template is required to allow creating a DualNum from an
    // expression; operator= does not do this because it requires an
    // already-existing DualNum object.
    // This constructor is not explicit because we want to allow automatic
    // conversion from an expression into a DualNum.
    //
    // The type used as E must support operator()(std::size_t) const.
    // Both DualNumSum ad DualNum itself meet the requirement.
    template <typename E>
    DualNum(E const& expr) : _real(real(expr), _dual(dual(expr)))
    {}

    // Note that DualNumSum has the same operator (only the const version).
    value_type
    real() const
    {
      return _real;
    }

    value_type
    dual() const
    {
      return _dual;
    }

    // These accessors allow assigning to a DualNum's components.
    // I am not sure we need them.
    value_type&
    real()
    {
      return _real;
    }

    value_type&
    dual()
    {
      return _dual;
    }

    DualNum& operator=(DualNum const&) = default;

    // This member template assignment operator evaluates an expression (such as
    // generated by DualNumSum) into the DualNum to which the assignment is
    // made. It merely evaluates each "slot" in the expression.
    template <typename E>
    DualNum&
    operator=(E const& expr)
    {
      _real = real(expr);
      _dual = dual(expr);
      return *this;
    }

  private:
    value_type _real;
    value_type _dual;
  };

  // Adding two expressions does not force evaluation of the expressions. This
  // is the key element of the expression template abstraction.
  template <typename LHS, typename RHS>
  DualNumSum<LHS, RHS>
  operator+(LHS const& lhs, RHS const& rhs)
  {
    return DualNumSum<LHS, RHS>(lhs, rhs);
  }

  template <typename LHS, typename RHS>
  DualNumProduct<LHS, RHS>
  operator*(LHS const& lhs, RHS const& rhs)
  {
    return DualNumProduct<LHS, RHS>(lhs, rhs);
  }

  // Implementations of the accessor interface overload set.
  inline DualNum::value_type
  dual(DualNum const& v)
  {
    return v.dual();
  }

  inline DualNum::value_type
  real(DualNum const& v)
  {
    return v.real();
  }

} // namespace duals

#endif