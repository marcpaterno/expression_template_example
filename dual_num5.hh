#ifndef DUAL_NUM_5_HH
#define DUAL_NUM_5_HH

#include <array>
#include <cstddef> // for std::size_t
// #include <ostream>

// expression template version of addition for DualNum uses the type
// DualNumSum to represent the unevaluated addition.

template <typename LHS, typename RHS>
class DualNumSum5 {
public:
  DualNumSum5(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

  // conversion of i'th element to the resulting sum of the i'th elements
  // of the represented expression. We return auto to delay evaluating
  // the expression for as long as possible.
  auto
  operator()(std::size_t i) const
  {
    return lhs(i) + rhs(i);
  }

private:
  // We contain references to avoid copying. This is acceptable because the
  // lifetime of an expression object is always, by construction, long enough to
  // let it be evaluated.
  LHS const& lhs;
  RHS const& rhs;
};

// expression template version of subtraction for DualNum uses the type
// DualNumDiff to represent the unevaluated subtraction.
template <typename LHS, typename RHS>
class DualNumDiff5 {
public:
  DualNumDiff5(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

  // conversion of i'th element to the resulting difference of the i'th
  // elements of the represented expression. We return auto to delay evaluating
  // the expression for as long as possible.
  auto
  operator()(std::size_t i) const
  {
    return lhs(i) - rhs(i);
  }

private:
  // We contain references to avoid copying. This is acceptable because the
  // lifetime of an expression object is always, by construction, long enough to
  // let it be evaluated.
  LHS const& lhs;
  RHS const& rhs;
};

// expression template version of multiplication for DualNum uses the type
// DualNumProduct to represent the unevaluated multiplication.

template <typename LHS, typename RHS>
class DualNumProduct5 {
public:
  //using value_type = typename LHS::value_type;

  DualNumProduct5(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

  // conversion of i'th element to the resulting product of the i'th
  // elements of the represented expression. We return auto to delay evaluating
  // the expression for as long as possible.
  auto
  operator()(std::size_t i) const
  {
    switch (i) {
      case 0: return lhs(0) * rhs(0);
      case 1: return lhs(0) * rhs(1) + rhs(0) * lhs(1);
      case 2: return lhs(0) * rhs(2) + rhs(0) * lhs(2);
      case 3: return lhs(0) * rhs(3) + rhs(0) * lhs(3);
      case 4: return lhs(0) * rhs(4) + rhs(0) * lhs(4);
    }
    return lhs(0) * rhs(5) + rhs(0) * lhs(5);
  }

private:
  // We contain references to avoid copying. This is acceptable because the
  // lifetime of an expression object is always, by construction, long enough to
  // let it be evaluated.
  LHS const& lhs;
  RHS const& rhs;
};

struct DualNum5 {
  // We need a nested type value_type, so that DualNum can be used
  // with the DualNumSum template.
  using value_type = double;

  // We store our data in a fixed-size array so that we can access them
  // generically in the operators.
  std::array<value_type, 6> vals;

  // Serves as default constructor, as well as 1- and 2-arg constructors.
  DualNum5() : vals{0.0, 0.0, 0.0, 0.0, 0.0, 0.0} {}
  DualNum5(double real) : vals{real, 0.0, 0.0, 0.0, 0.0, 0.0} {}
  DualNum5(double real, double d1, double d2, double d3, double d4, double d5)
    : vals{real, d1, d2, d3, d4, d5}
  {}

  // This constructor template is required to allow creating a DualNum from an
  // expression; operator= does not do this because it requires an
  // already-existing DualNum object.
  // This constructor is not explicit because we want to allow automatic
  // conversion from an expression into a DualNum.
  //
  // The type used as E must support operator()(std::size_t) const.
  // Both DualNumSum ad DualNum itself meet the requirement.
  // Creating a DualNum from an expression forces the evaluation of the
  // expression.
  template <typename E>
  DualNum5(E const& expr)
    : vals{expr(0), expr(1), expr(2), expr(3), expr(4), expr(5)}
  {}

  // Note that DualNumSum has the same operator (only the const version).
  value_type
  operator()(std::size_t i) const
  {
    return vals[i];
  }

  value_type&
  operator()(std::size_t i)
  {
    return vals[i];
  }

  // This member template assignment operator evaluates an expression (such as
  // generated by DualNumSum) into the DualNum to which the assignment is made.
  // It merely evaluates each "slot" in the expression.
  template <typename E>
  DualNum5&
  operator=(E const& expr)
  {
    vals[0] = expr(0);
    vals[1] = expr(1);
    vals[2] = expr(2);
    vals[3] = expr(3);
    vals[4] = expr(4);
    vals[5] = expr(5);
    return *this;
  }
};

// inline
// std::ostream&
// operator<<(std::ostream& os, DualNum5 const& x)
// {
//   os << x(0) << ' ' << x(1) << ' ' << x(2) << ' '
//     << x(3) << ' ' << x(4) << ' ' << x(5) << '\n';
//   return os;
// }

// Equality testing for DualNum checks the components.
inline bool
operator==(DualNum5 const& x, DualNum5 const& y)
{
  return (x(0) == y(0)) && (x(1) == y(1)) && (x(2) == y(2)) && (x(3) == y(3)) &&
         (x(4) == y(4)) && (x(5) == y(5));
}

// We support the suffix _dn on a floating-point literal, or an integer literal,
// to create a DualNum.
inline DualNum5 operator"" _dn(long double x)
{
  return DualNum5(static_cast<double>(x));
}

inline DualNum5 operator"" _dn(unsigned long long x)
{
  return DualNum5(static_cast<double>(x));
}

// Adding two expressions does not force evaluation of the expressions. This is
// the key element of the expression template abstraction.

template <typename LHS, typename RHS>
DualNumSum5<LHS, RHS>
operator+(LHS const& lhs, RHS const& rhs)
{
  return DualNumSum5<LHS, RHS>(lhs, rhs);
}

template <typename LHS, typename RHS>
DualNumDiff5<LHS, RHS>
operator-(LHS const& lhs, RHS const& rhs)
{
  return DualNumDiff5<LHS, RHS>(lhs, rhs);
}

template <typename LHS, typename RHS>
DualNumProduct5<LHS, RHS>
operator*(LHS const& lhs, RHS const& rhs)
{
  return DualNumProduct5<LHS, RHS>(lhs, rhs);
}

inline DualNum5
operator+(DualNum5 const& x, double y)
{
  return x + DualNum5(y);
}

inline DualNum5
operator+(double x, DualNum5 const& y)
{
  return DualNum5(x) + y;
}

inline DualNum5
operator-(DualNum5 const& x, double y)
{
  return x - DualNum5(y);
}

inline DualNum5
operator-(double x, DualNum5 const& y)
{
  return DualNum5(x) - y;
}

inline DualNum5
operator*(DualNum5 const& x, double y)
{
  return x * DualNum5(y);
}

inline DualNum5
operator*(double x, DualNum5 const& y)
{
  return DualNum5(x) * y;
}

template <typename EXPR>
auto
operator+(EXPR const& x, double y)
{
  // We can not use the simple form:
  // return x + DualNum(y);
  // because this uses a dangling pointer to an unnamed temporary.
  //
  // This implementation forces the evaluation of x, the left hand side of the
  // expression using the double. This may lead to inefficiency.
  DualNum5 temp{x};
  return temp + y;
}

template <typename EXPR>
auto
operator-(EXPR const& x, double y)
{
  DualNum5 temp{x};
  return temp - y;
}

template <typename EXPR>
auto
operator*(EXPR const& x, double y)
{
  DualNum5 temp{x};
  return temp * y;
}

void print(DualNum5 const& x);

#endif
