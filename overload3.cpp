#include <array>
#include <cstdio>

// expression template version of addition for DualNum uses the type
// DualNumSum to represent the unevaluated addition.

template <typename LHS, typename RHS>
class DualNumSum {
public:
  using value_type = typename LHS::value_type;

  DualNumSum(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

  value_type
  real() const
  {
    return lhs.real() + rhs.real();
  }
  value_type
  dual() const
  {
    return lhs.dual() + rhs.dual();
  }

private:
  // We contain references to avoid copying. This is acceptable because the
  // lifetime of an expression object is always, by construction, long enough to
  // let it be evaluated.
  LHS const& lhs;
  RHS const& rhs;
};

// expression template version of multiplication for DualNum uses the type
// DualNumProduct to represent the unevaluated multiplication.

template <typename LHS, typename RHS>
class DualNumProduct {
public:
  using value_type = typename LHS::value_type;

  DualNumProduct(LHS const& lhs, RHS const& rhs) : lhs(lhs), rhs(rhs) {}

  value_type
  real() const
  {
    return lhs.real() * rhs.real();
  }
  value_type
  dual() const
  {
    return lhs.real() * rhs.dual() + lhs.dual() * rhs.real();
  }

private:
  // We contain references to avoid copying. This is acceptable because the
  // lifetime of an expression object is always, by construction, long enough to
  // let it be evaluated.
  LHS const& lhs;
  RHS const& rhs;
};

class DualNum {
public:
  // We need a nested type value_type, so that DualNum can be used
  // withh the DualNumSum template.
  using value_type = double;

  // Serves as default constructor, as well as 1- and 2-arg constructors.
  DualNum(double real = 0.0, double dual = 0.0) : _real(real), _dual(dual) {}

  // This constructor template is required to allow creating a DualNum from an
  // expression; operator= does not do this because it requires an
  // already-existing DualNum object.
  // This constructor is not explicit because we want to allow automatic
  // conversion from an expression into a DualNum.
  //
  // The type used as E must support operator()(std::size_t) const.
  // Both DualNumSum ad DualNum itself meet the requirement.
  template <typename E>
  DualNum(E const& expr) : _real(expr.real(), _dual(expr.dual()))
  {}

  // Note that DualNumSum has the same operator (only the const version).
  value_type
  real() const
  {
    return _real;
  }
  value_type
  dual() const
  {
    return _dual;
  }

  // These accessors allow assigning to a DualNum's components.
  // I am not sure we need them.
  value_type&
  real()
  {
    return _real;
  }
  value_type&
  dual()
  {
    return _dual;
  }

  DualNum& operator=(DualNum const&) = default;

  // This member template assignment operator evaluates an expression (such as
  // generated by DualNumSum) into the DualNum to which the assignment is made.
  // It merely evaluates each "slot" in the expression.
  template <typename E>
  DualNum&
  operator=(E const& expr)
  {
    _real = expr.real();
    _dual = expr.dual();
    return *this;
  }

private:
  value_type _real;
  value_type _dual;
};

// Adding two expressions does not force evaluation of the expressions. This is
// the key element of the expression template abstraction.
template <typename LHS, typename RHS>
DualNumSum<LHS, RHS>
operator+(LHS const& lhs, RHS const& rhs)
{
  return DualNumSum<LHS, RHS>(lhs, rhs);
}

template <typename LHS, typename RHS>
DualNumProduct<LHS, RHS>
operator*(LHS const& lhs, RHS const& rhs)
{
  return DualNumProduct<LHS, RHS>(lhs, rhs);
}

int
main()
{
  DualNum x0(1.0, 0.5), x1(2.0, 1.5), x2(3.0, 2.5), x3(4.0, 3.5);
  DualNum y = x0 + x1 + x2 + x3 + 5.0;
  printf("outputs:  %f   %f\n", y.real(), y.dual());

  DualNum z;
  z = x0 * x1 * x2 * x3;
  printf("outputs:  %f   %f\n", z.real(), z.dual());
}
